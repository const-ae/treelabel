% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test_abundance_change.R
\name{test_abundance_changes}
\alias{test_abundance_changes}
\title{Test if the abundance of a label changes between conditions}
\usage{
test_abundance_changes(
  data,
  design,
  aggregate_by,
  contrast = NULL,
  treelabels = tidyselect::where(is_treelabel),
  targets = NULL,
  reference = NULL,
  model = c("quasipoisson", "poisson", "quasibinomial", "binomial"),
  ridge_penalty = 0.001,
  return_aggregated_data = FALSE
)
}
\arguments{
\item{data}{an object that can be converted to a \code{data.frame}, which contains one row for each cell
with meta data:
\itemize{
\item one or more columns with the condition information (used in \code{design}),
\item one or more columns with the sample information which describes our replicates (used in \code{aggregate_by}),
\item one or more \code{treelabel} columns with the cell type annotation (used in \code{treelabels}).
}}

\item{design}{a formula or design matrix that describes the experimental design (e.g., \code{design = ~ status}).}

\item{aggregate_by}{a <\code{\link[=dplyr_tidy_select]{tidy-select}}> expression which defines the independent unit of replication for this
experiment (e.g., \code{aggregate_by = c(sample_id)}).}

\item{contrast}{a contrast expression that defines the conditions across which we compare the abundance
changes. This can be a contrast vector (i.e., \code{c(0,1,-1,0)}) or a contrast expression that can refer
to levels of covariates mentioned in the \code{design} (\code{cond(status = "treated") - cond(status = "control")}).
Default: \code{NULL} in which case the first two levels of the first factor level from the design are compared.}

\item{treelabels}{a <\code{\link[=dplyr_tidy_select]{tidy-select}}> expression that selects the column or columns with the cell type annotation.
Default: \code{where(is_treelabel)} which selects all column of class \code{treelabel}.}

\item{targets}{a <\code{\link[rlang:args_data_masking]{data-masking}}> expression vector (wrapped with \code{vars}) or a character vector that defines which
cell type labels are counted. If the \code{treelabel} contains confidence scores, you should convert them to
booleans either before calling \code{test_abundance_changes} or using \code{targets = vars(Macrophage > 0.7, T_Cell > 0.6)}.
Default: \code{NULL} in which case all labels below the \code{reference} label are tested.}

\item{reference}{a single <\code{\link[rlang:args_data_masking]{data-masking}}> expression (not wrapped with \code{vars}!) that defines
which cell label is used as a reference. For example, if the \code{treelabel} describes immune cells with two annotation levels, where
the first level is \emph{Myeloid} and \emph{Lymphoid} cells and the second level for the Myeloid cells is \emph{Monocytes} and \emph{Macrophages},
we could count the abundance change of \emph{Macrophages} as a fraction of all cells (i.e., \code{reference = "root"}) or as a fraction of
\emph{Myeloid} cells (i.e., \code{reference = Myeloid > 0.7}).

Default: \code{NULL} in which case the root of the \code{treelabel} is used as a reference.}

\item{model}{the statistical model that is used to test for abundance changes. I recommend using a quasi-poisson or quasi-binomial
model to account for the count overdispersion. Default: \code{"quasipoisson"}.}

\item{ridge_penalty}{a small penalty added to the fit to aid convergence. Default: \code{0.001}.}

\item{return_aggregated_data}{see \emph{Returns} section.}
}
\value{
By default, the function returns a \code{tibble} with one row per statistical test that was conducted with the following columns
\itemize{
\item \code{treelabel}: the name of the selected \code{treelabel} column.
\item \code{target}: the name of the cell type label for which we test the abundance change.
\item \code{LFC}/\code{LogOdds}/\code{Delta}: the magnitude of the change. The name and interpretation of the column depends on the model family.
\item \code{LFC_se}/\code{LogOdds_se}/\code{Delta_se}: the standard error of the estimate.
\item \code{dispersion}: the variance of the residuals around the estimate.
\item \code{pval}: the significance of the estimate.
\item \code{adj_pval}: Benjamini-Hochberg adjusted p-values (i.e., the false discovery rate (FDR))
\item If any GLM call fails, the data frame contains an extra \code{error} column with the error message.
}

If \code{return_aggregated_data = TRUE}, the function returns a tibble that contains the aggregated data that would usually
be used to fit the statistical models.
}
\description{
Test if the abundance of a label changes between conditions
}
\examples{
  tree <- igraph::graph_from_literal(
    Animal - Bird : Mammal,
    Bird - Parrot : Eagle,
    Mammal - Dog : Cat
  )
  animal <- c("Parrot", "Eagle", "Dog", "Cat")
  df <- rbind(
  data.frame(group = "A",
             sample = sample(1:4, size = 1000, replace = TRUE),
             animal = sample(animal, size = 1000, prob = c(0.4, 0.25, 0.25, 0.1), replace = TRUE)),
  data.frame(group = "B",
             sample = sample(1:4, size = 1000, prob = c(0.25, 0.25, 0.25, 0.25), replace = TRUE),
             animal = sample(animal, size = 1000, replace = TRUE))
  )

  df$tl <- treelabel(df$animal, tree = tree, tree_root = "Animal")
  res <- test_abundance_changes(df, design = ~ group, aggregate_by = c(group, sample),
                                targets = vars(Dog, Cat), reference = Animal, model = "poisson")
  res

  # The underlying data: This can be useful for plotting or sanity checks.
  test_abundance_changes(df, design = ~ group, aggregate_by = c(group, sample),
                         targets = vars(Dog, Cat), reference = Animal,
                         return_aggregated_data = TRUE)

}
